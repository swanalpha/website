<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-WJJX7CQ79D"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-WJJX7CQ79D');
  </script>
  <meta charset="UTF-8" />
  <title>SWAN Alpha — Daily Market Regime Signal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Daily SPY market regime signal with a live overlay, historical backtests, and example SWAN portfolio performance."
  />
  <link rel="icon" href="/favicon.ico" />

  <!-- Tailwind (local build) -->
  <link rel="stylesheet" href="assets/tailwind.css" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
    rel="stylesheet"
  />

  <!-- Lightweight Charts v5 (local copy) -->
  <script src="assets/lightweight-charts.production.min.js"></script>

  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    .hero-buckets {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.75rem;
    }
    .regime-comparison {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .regime-summary {
      display: flex;
      align-items: flex-start;
      gap: 1.5rem;
    }
    .regime-summary .regime-item {
      flex: 1 1 auto;
    }
    .regime-summary .live-status-card {
      flex: 0 0 16rem;
    }
    .live-status-card {
      position: relative;
      border-color: rgba(16, 185, 129, 0.35);
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(15, 23, 42, 0.85) 60%, rgba(16, 185, 129, 0.12) 100%);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.7), 0 0 0 1px rgba(16, 185, 129, 0.2);
    }
    .live-status-card::before {
      content: '';
      position: absolute;
      top: 10px;
      bottom: 10px;
      left: -1px;
      width: 3px;
      border-radius: 3px;
      background: linear-gradient(180deg, #34d399, #22d3ee);
      opacity: 0.9;
    }
    @media (min-width: 768px) {
      .regime-comparison {
        flex-direction: row;
        align-items: flex-start;
      }
      .regime-comparison > .regime-item {
        flex: 1 1 50%;
      }
    }
  </style>
</head>
<body class="bg-slate-950 text-slate-100">
  <!-- Page wrapper -->
  <div class="min-h-screen flex flex-col">

    <!-- Top nav -->
    <header class="border-b border-slate-800 bg-slate-950/90 backdrop-blur">
      <div class="max-w-6xl mx-auto flex items-center justify-between px-4 py-3">
        <div class="flex items-center gap-3">
          <div class="h-9 w-9 rounded-xl bg-gradient-to-br from-emerald-400 via-emerald-500 to-sky-500 shadow-lg shadow-emerald-500/30 flex items-center justify-center">
            <span class="text-slate-950 font-black text-lg">S</span>
          </div>
          <div class="leading-tight">
            <div class="text-sm font-semibold tracking-wide">SWAN Alpha</div>
            <div class="text-[11px]">Sleep <span class="text-emerald-400">Well</span>. Stay <span class="text-emerald-400">Invested</span>.</div>
          </div>
        </div>
      </div>
    </header>

    <!-- Main content -->
    <main class="flex-1">
      <div class="max-w-6xl mx-auto px-4 py-6 md:py-10 space-y-8">

        <!-- Hero / Today’s signal -->
        <section class="space-y-4">
          <div class="space-y-4 text-slate-400">
            <span class="text-3xl font-semibold tracking-tight text-emerald-400">
              SWAN Alpha
            </span>
            is a quantitative framework for serious, hands-on investors who want equity-like returns with more controlled risk and drawdowns.
            <ul class="mt-4 hero-buckets text-[13px]">
              <li class="h-full rounded-lg border border-slate-800 bg-slate-900/60 p-3 shadow-sm shadow-emerald-500/10">
                <div class="text-emerald-400 font-semibold mb-1 text-lg">Regime Signals</div>
                <div class="text-slate-300/90">Data-driven regime classification to show when conditions favor taking risk and when they call for defense.</div>
              </li>
              <li class="h-full rounded-lg border border-slate-800 bg-slate-900/60 p-3 shadow-sm shadow-emerald-500/10">
                <div class="text-emerald-400 font-semibold mb-1 text-lg">Model Portfolios</div>
                <div class="text-slate-300/90">Allocations tuned to each regime, designed to balance return and drawdown. <i>(Upcoming)</i></div>
              </li>
              <li class="h-full rounded-lg border border-slate-800 bg-slate-900/60 p-3 shadow-sm shadow-emerald-500/10">
                <div class="text-emerald-400 font-semibold mb-1 text-lg">Alpha Overlays</div>
                <div class="text-slate-300/90">Tactical models (e.g., pullback / bottom tools) aiming to enhance returns without abandoning risk discipline. <i>(Upcoming)</i></div>
              </li>
            </ul>
          </div>
        </section>

        <!-- Live SPY regime & price chart -->
        <section class="space-y-3">
          <div class="flex items-center justify-between gap-2">
            <h2 class="text-sm md:text-base font-semibold text-slate-100">
              SPY Price with <span class="text-emerald-400">Live Regime Signals</span>
            </h2>
          </div>
          <div class="regime-summary">
            <div class="regime-item text-slate-400 leading-relaxed">
              Market Regime refers to the prevailing market environment characterized by distinct patterns
              of price behavior, volatility, and risk-return dynamics. Our algorithm identifies three regimes:
              Bull (favorable conditions for equity exposure), Neutral (mixed signals requiring moderate positioning),
              and Bear (defensive conditions favoring cash or low-risk assets). The colored bars below the price chart
              show regimes predicted by our algorithm.
            </div>
            <div class="live-status-card rounded-xl border border-slate-800 bg-slate-900/70 px-4 py-3 text-[11px] text-slate-300">
              <div class="text-[10px] uppercase tracking-[0.2em] text-slate-500">Live status</div>
              <div class="mt-2 space-y-1">
                <div>Current Regime: <span id="spy-current-regime" class="font-semibold text-emerald-400">—</span></div>
                <div>Target exposure: <span id="spy-target-exposure" class="font-semibold text-slate-100">—</span></div>
                <div id="spy-as-of" class="text-slate-400">as of —</div>
              </div>
            </div>
          </div>

          <div class="bg-slate-900/60 border border-slate-800 rounded-2xl p-3 md:p-4 space-y-3">
            <div id="spy-price-chart" class="h-72 md:h-80"></div>
            <div id="spy-regime-strip" class="hidden h-0 mt-0"></div>
            <div class="mt-2 flex flex-wrap gap-3 text-[11px] text-slate-400">
              <div class="flex items-center gap-1.5">
                <span class="inline-block h-2 w-4 rounded bg-emerald-500"></span>
                Bull Regime
              </div>
              <div class="flex items-center gap-1.5">
                <span class="inline-block h-2 w-4 rounded" style="background-color: #eab308;"></span>
                Neutral Regime
              </div>
              <div class="flex items-center gap-1.5">
                <span class="inline-block h-2 w-4 rounded bg-rose-500"></span>
                Bear Regime
              </div>
            </div>
          </div>
        </section>

        <!-- Live performance section -->
          <div class="space-y-3">
            <div class="flex items-center justify-between gap-2">
              <h2 class="text-sm md:text-base font-semibold text-slate-100">
                Regime-Based Exposure Strategy
              </h2>
            </div>
            <div class="regime-item text-slate-400 leading-relaxed">
              Regime-Based Exposure adjusts SPY or portfolio allocation based on a quantitative view of
              the current market regime (e.g., Bull 100%, Neutral 50%, Bear 0%), while “Buy &amp; Hold”
              stays 100% invested at all times. This dynamic approach aims to preserve most of SPY’s
              long-term return with much smaller drawdowns.
            </div>
            <div class="bg-slate-900/60 border border-slate-800 rounded-2xl p-4 space-y-4">
              <div class="grid md:grid-cols-[2fr,1fr] gap-4 items-start">
                <div>
                  <div class="overflow-x-auto max-w-6xl">
                    <table class="w-full md:w-auto min-w-[800px] text-[13px] text-left">
                      <thead class="text-slate-400">
                        <tr>
                          <th class="pr-3 pb-2 pt-1">Period</th>
                          <th class="pr-3 pb-2 pt-1">Strategy</th>
                          <th class="pr-3 pb-2 pt-1 text-right">
                            <a href="https://en.wikipedia.org/wiki/Compound_annual_growth_rate" target="_blank" class="text-slate-400 hover:text-slate-200 underline decoration-dotted underline-offset-2">CAGR</a>
                          </th>
                          <th class="pr-3 pb-2 pt-1 text-right">
                            <a href="https://en.wikipedia.org/wiki/Drawdown_(economics)" target="_blank" class="text-slate-400 hover:text-slate-200 underline decoration-dotted underline-offset-2">MaxDD</a>
                          </th>
                          <th class="pr-3 pb-2 pt-1 text-right">
                            <a href="https://en.wikipedia.org/wiki/Calmar_ratio" target="_blank" class="text-slate-400 hover:text-slate-200 underline decoration-dotted underline-offset-2">Calmar</a>
                          </th>
                          <th class="pr-3 pb-2 pt-1 text-right">
                            <a href="https://en.wikipedia.org/wiki/Sharpe_ratio" target="_blank" class="text-slate-400 hover:text-slate-200 underline decoration-dotted underline-offset-2">Sharpe</a>
                          </th>
                          <th class="pr-3 pb-2 pt-1 text-right">
                            <a href="https://en.wikipedia.org/wiki/Sortino_ratio" target="_blank" class="text-slate-400 hover:text-slate-200 underline decoration-dotted underline-offset-2">Sortino</a>
                          </th>
                          <th class="pr-3 pb-2 pt-1 text-right">
                            <a href="https://en.wikipedia.org/wiki/Volatility_(finance)" target="_blank" class="text-slate-400 hover:text-slate-200 underline decoration-dotted underline-offset-2">Volatility</a>
                          </th>
                        </tr>
                      </thead>
                      <tbody id="bt-subperiod-body">
                        <!-- Rows injected by JS -->
                      </tbody>
                    </table>
                  </div>
                </div>

                <div class="bg-slate-800/30 rounded-lg p-4 space-y-3">
                  <p class="font-semibold text-slate-200 text-sm">Disclaimers</p>
                  <ul class="text-[11px] text-slate-400 space-y-2 leading-relaxed">
                    <li class="flex items-start gap-2">
                      <span class="text-slate-500 mt-0.5">•</span>
                      <span>These results are for research and educational purposes only and do not constitute investment advice or an offer to invest in any product.</span>
                    </li>
                    <li class="flex items-start gap-2">
                      <span class="text-slate-500 mt-0.5">•</span>
                      <span>Historical performance is not a guarantee of future results.</span>
                    </li>
                    <li class="flex items-start gap-2">
                      <span class="text-slate-500 mt-0.5">•</span>
                      <span>The live signal may underperform SPY or incur losses over any time horizon.</span>
                    </li>
                    <li class="flex items-start gap-2">
                      <span class="text-slate-500 mt-0.5">•</span>
                      <span>Backtests use open-close execution with no transaction costs, taxes, or slippage modeled.</span>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        </section>

        <section class="space-y-6 pt-2">
        <!-- SWAN live comparison -->
          <div class="space-y-3">
            <h2 class="text-sm md:text-base font-semibold text-slate-100">
              Live SWAN Portfolio Performance
            </h2>
            <p class="text-slate-400">
              The SWAN Portfolio is a live model portfolio that applies the SWAN Alpha regime-based allocation framework to a diversified mix of assets. It aims to improve the risk/return profile relative to a simple SPY Buy &amp; Hold approach. The chart shows its real-time performance since launch, compared with SPY and an internal SWAN Buy &amp; Hold benchmark.
            </p>

            <div class="bg-slate-900/60 border border-slate-800 rounded-2xl p-3 md:p-4 space-y-3">
              <div class="flex flex-wrap gap-3 text-[11px] text-slate-300">
                <div class="flex items-center gap-2">
                  <span class="font-semibold text-emerald-300">SWAN + Regime</span>
                  <span id="swan-live-overlay-metrics" class="text-slate-400">(CAGR: –, Sharpe: –)</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="font-semibold text-orange-300">SWAN B&amp;H</span>
                  <span id="swan-live-bh-metrics" class="text-slate-400">(CAGR: –, Sharpe: –)</span>
                </div>
                <div class="flex items-center gap-2">
                  <span class="font-semibold text-sky-300">SPY B&amp;H</span>
                  <span id="swan-live-spy-metrics" class="text-slate-400">(CAGR: –, Sharpe: –)</span>
                </div>
              </div>
              <div id="swan-equity-chart" class="h-56"></div>
              <div class="mt-2 flex flex-wrap gap-3 text-[11px] text-slate-400">
                <div class="flex items-center gap-1.5">
                  <span class="inline-block h-2 w-4 rounded bg-emerald-400"></span>
                  SWAN + Regime
                </div>
                <div class="flex items-center gap-1.5">
                  <span class="inline-block h-2 w-4 rounded bg-orange-400"></span>
                  SWAN Buy &amp; Hold
                </div>
                <div class="flex items-center gap-1.5">
                  <span class="inline-block h-2 w-4 rounded bg-sky-400"></span>
                  SPY Buy &amp; Hold
                </div>
              </div>
            </div>
            <div class="flex items-center justify-between gap-2">
              <div class="text-[11px] text-slate-500">
                Portfolio details and allocation strategy not disclosed · performance is real-time
              </div>
            </div>
          </div>
        </section>

      </div>
    </main>

    <!-- Footer -->
    <footer class="border-t border-slate-800 mt-6">
      <div class="max-w-6xl mx-auto px-4 py-3 flex flex-wrap items-center justify-between gap-2 text-[11px] text-slate-500">
        <span>© <span id="footer-year"></span> SWAN Alpha (personal research project).</span>
        <span>This site is for informational and educational purposes only. Not investment advice.</span>
      </div>
    </footer>
  </div>

  <!-- Page script -->
  <script>
    const CONFIG = {
      dataUrl: 'data/regime.json',
      swanDataUrl: 'data/swan.json',
    };

    const { createChart } = LightweightCharts;

    function fmtPct(x, digits = 1) {
      if (x === null || x === undefined || isNaN(x)) return '–';
      return (x * 100).toFixed(digits) + '%';
    }

    function fmtPctSigned(x, digits = 1) {
      if (x === null || x === undefined || isNaN(x)) return '–';
      const v = (x * 100).toFixed(digits);
      return (x >= 0 ? '+' : '') + v + '%';
    }

    function fmtNumber(x, digits = 0) {
      if (x === null || x === undefined || isNaN(x)) return '–';
      return Number(x).toLocaleString(undefined, {
        maximumFractionDigits: digits,
      });
    }

    function fmtDateStr(s) {
      if (!s) return '';
      return s;
    }

    // ------------------------------------------------------------
    // 1) Load JSONs and drive the page
    // ------------------------------------------------------------

    async function loadJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to load ' + url);
      return res.json();
    }

    async function initPage() {
      document.getElementById('footer-year').textContent =
        new Date().getFullYear();

      let mainData = null;
      let swanData = null;

      try {
        // Load main data.json and swan.json
        [mainData, swanData] = await Promise.all([
          loadJson(CONFIG.dataUrl).catch(() => null),
          loadJson(CONFIG.swanDataUrl).catch(() => null),
        ]);
      } catch (err) {
        console.error('Error loading data:', err);
      }

      // Use mainData for SPY charts
      if (mainData) {
        renderSpyPriceAndRegimeCharts(mainData);
      }

      // Use swanData for SWAN performance
      if (swanData) {
        renderSwanStatsAndChart(swanData);

        // Update the "as of" timestamp in the SPY section
        const asOfEl = document.getElementById('spy-as-of');
        if (asOfEl && swanData.as_of) {
          // Parse the timestamp (already in Eastern time from swan.py)
          const timestampStr = swanData.as_of.replace(' EST', '').replace(' EDT', '');
          const timestamp = new Date(timestampStr.replace(' ', 'T'));

          // Format for display in Eastern time
          const formatted = timestamp.toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true,
            timeZone: 'America/New_York'
          });
          asOfEl.textContent = `as of ${formatted} ET`;
        }
      }

      // Use benchmarks from mainData for backtest rendering
      if (mainData && mainData.benchmarks) {
        renderBacktestFromBenchmarks(mainData.benchmarks);
      }
    }

    // ------------------------------------------------------------
    // 2) SPY header (regime + live stats)
    // ------------------------------------------------------------

    function updateSpyLiveStatus(regimes) {
      const regimeEl = document.getElementById('spy-current-regime');
      const exposureEl = document.getElementById('spy-target-exposure');
      if (!regimeEl || !exposureEl || !Array.isArray(regimes) || !regimes.length) {
        return;
      }

      const latest = regimes[regimes.length - 1];
      const regimeValue = String(latest.regime || '').toUpperCase();
      const mapping = {
        BULL: { label: 'Bull', exposure: '100%', className: 'text-emerald-400' },
        NEUTRAL: { label: 'Neutral', exposure: '50%', className: 'text-amber-400' },
        BEAR: { label: 'Bear', exposure: '0%', className: 'text-rose-400' },
      };
      const current = mapping[regimeValue] || {
        label: 'Unknown',
        exposure: '—',
        className: 'text-slate-200',
      };

      regimeEl.textContent = current.label;
      regimeEl.classList.remove('text-emerald-400', 'text-amber-400', 'text-rose-400', 'text-slate-200');
      regimeEl.classList.add(current.className);
      exposureEl.textContent = current.exposure;

      const asOfEl = document.getElementById('spy-as-of');
      if (asOfEl && asOfEl.textContent.includes('—') && latest.time) {
        const timestamp = new Date(latest.time);
        if (!Number.isNaN(timestamp.valueOf())) {
          const formatted = timestamp.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            timeZone: 'America/New_York',
          });
          asOfEl.textContent = `as of ${formatted} ET`;
        }
      }
    }

    // ------------------------------------------------------------
    // 3) SPY price + regime charts
    // ------------------------------------------------------------

    function renderSpyPriceAndRegimeCharts(data) {
      const containerPrice = document.getElementById('spy-price-chart');
      if (!containerPrice) return;

      // Handle both new data.json format and legacy format
      let candles = [];
      let regimes = [];

      if (data.history && Array.isArray(data.history)) {
        // New data.json format - convert history to candles and regimes
        // Filter to show only from 2000 onwards
        const filteredHistory = data.history.filter(item => {
          const itemDate = new Date(item.date);
          return itemDate >= new Date('2000-01-01');
        });

        candles = filteredHistory.map(item => ({
          time: item.date,
          open: item.open,
          high: item.high,
          low: item.low,
          close: item.close,
        }));

        regimes = filteredHistory.map(item => ({
          time: item.date,
          regime: item.regime.toUpperCase(),
        }));
      } else {
        // Legacy format - also filter from 2000 onwards
        const rawCandles = (data.chart && data.chart.candles) || [];
        const rawRegimes = (data.chart && data.chart.regimes) || [];

        candles = rawCandles.filter(c => new Date(c.time) >= new Date('2000-01-01'));
        regimes = rawRegimes.filter(r => new Date(r.time) >= new Date('2000-01-01'));
      }

      if (!candles.length) return;

      updateSpyLiveStatus(regimes);

      const priceChart = createChart(containerPrice, {
        layout: {
          background: { color: '#020617' },
          textColor: '#e5e7eb',
        },
        rightPriceScale: {
          borderColor: '#1f2937',
        },
        timeScale: {
          borderColor: '#1f2937',
        },
        grid: {
          vertLines: { color: '#020617' },
          horzLines: { color: '#020617' },
        },
        crosshair: {
          mode: 0,
        },
      });

      // Use the same area/line style as the performance chart for consistency.
      const priceSeries = priceChart.addAreaSeries({
        lineColor: '#38bdf8',
        topColor: 'rgba(56, 189, 248, 0.25)',
        bottomColor: 'rgba(56, 189, 248, 0.0)',
        priceLineVisible: false,
        lastValueVisible: false,
      });

      priceSeries.setData(
        candles.map(c => ({
          time: c.time,
          value: c.close,
        }))
      );

      // Overlay regime strip on the same chart using a dedicated price scale.
      const regimeSeries = priceChart.addHistogramSeries({
        priceFormat: { type: 'price', precision: 0, minMove: 1 },
        priceScaleId: 'regime',
        priceLineVisible: false,
        lastValueVisible: false,
      });
      priceChart.priceScale('regime').applyOptions({
        scaleMargins: { top: 0.9, bottom: 0 },
        borderVisible: false,
      });

      const stripData = regimes.map(r => {
        const regime = String(r.regime || '').toUpperCase();
        let color = '#eab308aa'; // neutral yellow

        if (regime === 'BULL') {
          color = '#22c55e55'; // green with transparency
        } else if (regime === 'BEAR') {
          color = '#ef4444aa'; // red with more opacity
        } else if (regime === 'NEUTRAL') {
          color = '#eab308aa'; // yellow with transparency
        }

        return {
          time: r.time,
          value: 1,
          color: color,
        };
      });
      regimeSeries.setData(stripData);

      // Trade markers (if any) - legacy format
      const trades = data.trades || [];
      const markers = trades.map(tr => {
        const side = (tr.side || tr.trade || '').toUpperCase();
        return {
          time: tr.time,
          position: side === 'BUY' ? 'belowBar' : 'aboveBar',
          color: side === 'BUY' ? '#22c55e' : '#ef4444',
          shape: side === 'BUY' ? 'arrowUp' : 'arrowDown',
          text: side === 'BUY' ? 'Buy' : 'Sell',
        };
      });


      if (markers.length > 0) {
        priceSeries.setMarkers(markers);
      }

      // Initial view: past 12 months (if available)
      if (candles.length > 0) {
        const parseDate = s => {
          const [y, m, d] = s.split('-').map(Number);
          return new Date(Date.UTC(y, m - 1, d));
        };
        const lastTime = parseDate(candles[candles.length - 1].time);
        const fromTime = new Date(lastTime);
        fromTime.setUTCFullYear(fromTime.getUTCFullYear() - 1);
        priceChart.timeScale().setVisibleRange({
          from: fromTime.toISOString().slice(0, 10),
          to: lastTime.toISOString().slice(0, 10),
        });
      }
    }

    function renderSwanStatsAndChart(swanData) {
      // Extract metrics from the new structure
      const metrics = swanData.metrics || {};
      const statsOverlay = metrics.swan_overlay || {};
      const statsSwanBh = metrics.swan_bh || {};
      const statsSpyBh = metrics.spy_bh || {};
      const curve = swanData.equity_curve || [];

      const overlayMetricsEl = document.getElementById('swan-live-overlay-metrics');
      const bhMetricsEl = document.getElementById('swan-live-bh-metrics');
      const spyMetricsEl = document.getElementById('swan-live-spy-metrics');

      const fmtSharpe = v => ((v ?? NaN).toFixed ? v.toFixed(2) : '–');

      if (overlayMetricsEl) {
        overlayMetricsEl.textContent = `(CAGR: ${fmtPct(statsOverlay.cagr ?? NaN, 1)}, Sharpe: ${fmtSharpe(statsOverlay.sharpe)})`;
      }
      if (bhMetricsEl) {
        bhMetricsEl.textContent = `(CAGR: ${fmtPct(statsSwanBh.cagr ?? NaN, 1)}, Sharpe: ${fmtSharpe(statsSwanBh.sharpe)})`;
      }
      if (spyMetricsEl) {
        spyMetricsEl.textContent = `(CAGR: ${fmtPct(statsSpyBh.cagr ?? NaN, 1)}, Sharpe: ${fmtSharpe(statsSpyBh.sharpe)})`;
      }

      const container = document.getElementById('swan-equity-chart');
      if (!container || !curve.length) return;

      const chart = createChart(container, {
        layout: {
          background: { color: '#020617' },
          textColor: '#e5e7eb',
        },
        rightPriceScale: {
          borderColor: '#1f2937',
        },
        timeScale: {
          borderColor: '#1f2937',
        },
        grid: {
          vertLines: { color: '#020617' },
          horzLines: { color: '#020617' },
        },
      });
      chart.applyOptions({
        localization: {
          priceFormatter: v => fmtNumber(v, 0),
        },
      });

      const overlaySeries = chart.addAreaSeries({
        lineColor: '#22c55e',
        topColor: 'rgba(34, 197, 94, 0.25)',
        bottomColor: 'rgba(34, 197, 94, 0.0)',
        priceLineVisible: false,
      });
      const swanBhSeries = chart.addAreaSeries({
        lineColor: '#f97316',
        topColor: 'rgba(249, 115, 22, 0.25)',
        bottomColor: 'rgba(249, 115, 22, 0.0)',
        priceLineVisible: false,
      });
      const spyBhSeries = chart.addAreaSeries({
        lineColor: '#38bdf8',
        topColor: 'rgba(56, 189, 248, 0.25)',
        bottomColor: 'rgba(56, 189, 248, 0.0)',
        priceLineVisible: false,
      });

      const overlayData = [];
      const swanBhData = [];
      const spyBhData = [];

      for (const row of curve) {
        overlayData.push({ time: row.time, value: row.swan_overlay });
        swanBhData.push({ time: row.time, value: row.swan_bh });
        spyBhData.push({ time: row.time, value: row.spy_bh });
      }

      overlaySeries.setData(overlayData);
      swanBhSeries.setData(swanBhData);
      spyBhSeries.setData(spyBhData);

      chart.timeScale().fitContent();
    }

    // ------------------------------------------------------------
    // 6) Backtest rendering from benchmarks data
    // ------------------------------------------------------------

    function renderBacktestFromBenchmarks(benchmarks) {
      const tbody = document.getElementById('bt-subperiod-body');
      if (!tbody) return;

      tbody.innerHTML = '';

      // Define the order of periods to display
      const periodOrder = ['2000-2007', '2008-2012', '2013-2019', '2000-Present'];

      // Define strategy order and display names
      const strategies = [
        { key: 'Regime', name: 'Regime-Based Exposure', class: 'text-slate-200' },
        { key: 'Buy&Hold', name: 'Buy & Hold', class: 'text-slate-200' },
        { key: 'MA200', name: 'MA200 Crossover', class: 'text-blue-300' },
        { key: 'Vol Targeting', name: 'Vol Targeting', class: 'text-purple-300' }
      ];

      // Define metrics and whether higher is better
      const metrics = [
        { key: 'CAGR', higherIsBetter: true },
        { key: 'MaxDD', higherIsBetter: true }, // Higher (less negative) is better for MaxDD
        { key: 'Calmar', higherIsBetter: true },
        { key: 'Sharpe', higherIsBetter: true },
        { key: 'Sortino', higherIsBetter: true },
        { key: 'Vol', higherIsBetter: false }
      ];

      // Function to find the best strategy for a metric in a period
      const findBestStrategy = (periodData, metric) => {
        let bestValue = metric.higherIsBetter ? -Infinity : Infinity;
        let bestStrategy = null;

        strategies.forEach(strategy => {
          const stats = periodData[strategy.key];
          if (stats && stats[metric.key] !== null && stats[metric.key] !== undefined && !isNaN(stats[metric.key])) {
            const value = stats[metric.key];
            if ((metric.higherIsBetter && value > bestValue) || (!metric.higherIsBetter && value < bestValue)) {
              bestValue = value;
              bestStrategy = strategy.key;
            }
          }
        });

        return bestStrategy;
      };

      let periodIndex = 0;
      for (const periodName of periodOrder) {
        const periodData = benchmarks[periodName];
        if (!periodData) continue;

        // Alternate background for each period group
        const bandStyle = (periodIndex % 2 === 0) ? 'background-color: rgba(30, 41, 59, 0.8);' : 'background-color: rgba(51, 65, 85, 0.4);';
        periodIndex++;

        // Find winners for each metric in this period
        const winners = {};
        metrics.forEach(metric => {
          winners[metric.key] = findBestStrategy(periodData, metric);
        });

        // Add rows for each strategy
        strategies.forEach((strategy, index) => {
          const stats = periodData[strategy.key] || {};
          const row = document.createElement('tr');

          const isFirstRow = index === 0;
          const isLastRow = index === strategies.length - 1;

          // Helper function to get cell class for highlighting winners
          const getCellClass = (metricKey) => {
            const isWinner = winners[metricKey] === strategy.key;
            return isWinner ? 'font-bold' : '';
          };

          // Helper function to get inline style for highlighting winners and borders
          const getCellStyle = (metricKey) => {
            const isWinner = winners[metricKey] === strategy.key;
            const winnerStyle = isWinner ? 'color: #f97316;' : '';
            const borderStyle = isLastRow ? 'border-bottom: 2px solid #475569;' : '';
            return `${winnerStyle} ${borderStyle}`;
          };

          // Helper function for non-metric cells (period, strategy name)
          const getBaseCellStyle = () => {
            return isLastRow ? 'border-bottom: 2px solid #475569;' : '';
          };

          row.innerHTML = `
            ${isFirstRow ? `<td class="pr-3 py-2" rowspan="${strategies.length}" style="${getBaseCellStyle()}">${periodName}</td>` : ''}
            <td class="pr-3 py-2 font-semibold ${strategy.class}" style="${getBaseCellStyle()}">${strategy.name}</td>
            <td class="pr-3 py-2 text-right ${getCellClass('CAGR')}" style="${getCellStyle('CAGR')}">${fmtPct(stats.CAGR ?? NaN, 1)}</td>
            <td class="pr-3 py-2 text-right ${getCellClass('MaxDD')}" style="${getCellStyle('MaxDD')}">${fmtPct(stats.MaxDD ?? NaN, 1)}</td>
            <td class="pr-3 py-2 text-right ${getCellClass('Calmar')}" style="${getCellStyle('Calmar')}">${(stats.Calmar ?? NaN).toFixed ? stats.Calmar.toFixed(2) : '–'}</td>
            <td class="pr-3 py-2 text-right ${getCellClass('Sharpe')}" style="${getCellStyle('Sharpe')}">${(stats.Sharpe ?? NaN).toFixed ? stats.Sharpe.toFixed(2) : '–'}</td>
            <td class="pr-3 py-2 text-right ${getCellClass('Sortino')}" style="${getCellStyle('Sortino')}">${(stats.Sortino ?? NaN).toFixed ? stats.Sortino.toFixed(2) : '–'}</td>
            <td class="pr-3 py-2 text-right ${getCellClass('Vol')}" style="${getCellStyle('Vol')}">${fmtPct(stats.Vol ?? NaN, 1)}</td>
          `;

          tbody.appendChild(row);
        });
      }
    }

    // ------------------------------------------------------------
    // 7) Backtest rendering (legacy)
    // ------------------------------------------------------------

    function renderBacktest(bt) {
      const full = bt.full_period || null;
      const subsRaw = bt.subperiods || {};
      const notes = bt.notes || [];
      const meta = bt.meta || {};

      const humanizeLabel = key =>
        key
          .split('_')
          .map(w => w.charAt(0).toUpperCase() + w.slice(1))
          .join(' ');

      const formatRange = (start, end) =>
        start && end ? `${start} → ${end}` : '';

      const subs = Array.isArray(subsRaw)
        ? subsRaw
        : Object.entries(subsRaw).map(([key, val]) => ({
            label: val?.label || humanizeLabel(key),
            ...val,
          }));

      if (full) {
        const s = full.strategy || full.overlay || {};
        const b = full.spy || {};
        const fullLabel =
          full.label ||
          formatRange(s.start_date, s.end_date) ||
          formatRange(meta.backtest_start, meta.backtest_end) ||
          'Full period';
        subs.unshift({
          label: fullLabel,
          overlay: s,
          spy: b,
        });
      }

      const tbody = document.getElementById('bt-subperiod-body');
      if (tbody) {
        tbody.innerHTML = '';
        let band = false;
        for (const sp of subs) {
          band = !band;
          const bandClass = band ? 'bg-slate-900/60' : 'bg-slate-900/40';
          const s = sp.strategy || sp.overlay || {};
          const b = sp.spy || {};
          const label =
            sp.label ||
            formatRange(s.start_date, s.end_date) ||
            formatRange(b.start_date, b.end_date) ||
            '';

          const rowOverlay = document.createElement('tr');
          rowOverlay.className = bandClass;
          rowOverlay.innerHTML = `
            <td class="pr-3 py-1 rounded-l-lg text-slate-200" rowspan="2">${label}</td>
            <td class="pr-3 py-1 font-semibold text-emerald-300">Regime-Based Allocation</td>
            <td class="pr-3 py-1 text-right">${fmtPct(s.cagr ?? NaN, 1)}</td>
            <td class="pr-3 py-1 text-right">${(s.sharpe ?? NaN).toFixed ? s.sharpe.toFixed(2) : '–'}</td>
            <td class="pr-3 py-1 text-right rounded-r-lg">${fmtPct(s.max_dd ?? NaN, 1)}</td>
          `;

          const rowSpy = document.createElement('tr');
          rowSpy.className = bandClass;
          rowSpy.innerHTML = `
            <td class="pr-3 py-1 font-semibold text-slate-200">Buy &amp; Hold</td>
            <td class="pr-3 py-1 text-right">${fmtPct(b.cagr ?? NaN, 1)}</td>
            <td class="pr-3 py-1 text-right">${(b.sharpe ?? NaN).toFixed ? b.sharpe.toFixed(2) : '–'}</td>
            <td class="pr-3 py-1 text-right rounded-r-lg">${fmtPct(b.max_dd ?? NaN, 1)}</td>
          `;

          tbody.appendChild(rowOverlay);
          tbody.appendChild(rowSpy);
        }
      }

      // Append extra notes (optional)
      if (notes.length) {
        const disclaimerBlock = document.querySelector(
          '#bt-subperiod-body'
        )?.parentElement?.parentElement?.nextElementSibling;
        if (disclaimerBlock) {
          const ul = document.createElement('ul');
          ul.className = 'list-disc list-inside space-y-0.5 mt-1';
          notes.forEach(n => {
            const li = document.createElement('li');
            li.textContent = n;
            ul.appendChild(li);
          });
          disclaimerBlock.appendChild(ul);
        }
      }
    }

    // Boot
    window.addEventListener('DOMContentLoaded', initPage);
  </script>
</body>
</html>
